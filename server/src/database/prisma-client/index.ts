// Code generated by Prisma (prisma@1.23.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  issue: (where?: IssueWhereInput) => Promise<boolean>;
  organization: (where?: OrganizationWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Comment>;
  commentsConnection: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentConnectionPromise;
  issue: (where: IssueWhereUniqueInput) => IssuePromise;
  issues: (
    args?: {
      where?: IssueWhereInput;
      orderBy?: IssueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Issue>;
  issuesConnection: (
    args?: {
      where?: IssueWhereInput;
      orderBy?: IssueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => IssueConnectionPromise;
  organization: (where: OrganizationWhereUniqueInput) => OrganizationPromise;
  organizations: (
    args?: {
      where?: OrganizationWhereInput;
      orderBy?: OrganizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Organization>;
  organizationsConnection: (
    args?: {
      where?: OrganizationWhereInput;
      orderBy?: OrganizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OrganizationConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (
    args: { data: CommentUpdateInput; where: CommentWhereUniqueInput }
  ) => CommentPromise;
  updateManyComments: (
    args: { data: CommentUpdateManyMutationInput; where?: CommentWhereInput }
  ) => BatchPayloadPromise;
  upsertComment: (
    args: {
      where: CommentWhereUniqueInput;
      create: CommentCreateInput;
      update: CommentUpdateInput;
    }
  ) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createIssue: (data: IssueCreateInput) => IssuePromise;
  updateIssue: (
    args: { data: IssueUpdateInput; where: IssueWhereUniqueInput }
  ) => IssuePromise;
  updateManyIssues: (
    args: { data: IssueUpdateManyMutationInput; where?: IssueWhereInput }
  ) => BatchPayloadPromise;
  upsertIssue: (
    args: {
      where: IssueWhereUniqueInput;
      create: IssueCreateInput;
      update: IssueUpdateInput;
    }
  ) => IssuePromise;
  deleteIssue: (where: IssueWhereUniqueInput) => IssuePromise;
  deleteManyIssues: (where?: IssueWhereInput) => BatchPayloadPromise;
  createOrganization: (data: OrganizationCreateInput) => OrganizationPromise;
  updateOrganization: (
    args: { data: OrganizationUpdateInput; where: OrganizationWhereUniqueInput }
  ) => OrganizationPromise;
  updateManyOrganizations: (
    args: {
      data: OrganizationUpdateManyMutationInput;
      where?: OrganizationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertOrganization: (
    args: {
      where: OrganizationWhereUniqueInput;
      create: OrganizationCreateInput;
      update: OrganizationUpdateInput;
    }
  ) => OrganizationPromise;
  deleteOrganization: (
    where: OrganizationWhereUniqueInput
  ) => OrganizationPromise;
  deleteManyOrganizations: (
    where?: OrganizationWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  issue: (
    where?: IssueSubscriptionWhereInput
  ) => IssueSubscriptionPayloadSubscription;
  organization: (
    where?: OrganizationSubscriptionWhereInput
  ) => OrganizationSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "email_ASC"
  | "email_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC";

export type IssueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "body_ASC"
  | "body_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "body_ASC"
  | "body_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC";

export type OrganizationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface ProductUpdateOneRequiredWithoutIssuesInput {
  create?: ProductCreateWithoutIssuesInput;
  update?: ProductUpdateWithoutIssuesDataInput;
  upsert?: ProductUpsertWithoutIssuesInput;
  connect?: ProductWhereUniqueInput;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OrganizationUpdateManyWithoutMembersInput {
  create?:
    | OrganizationCreateWithoutMembersInput[]
    | OrganizationCreateWithoutMembersInput;
  delete?: OrganizationWhereUniqueInput[] | OrganizationWhereUniqueInput;
  connect?: OrganizationWhereUniqueInput[] | OrganizationWhereUniqueInput;
  disconnect?: OrganizationWhereUniqueInput[] | OrganizationWhereUniqueInput;
  update?:
    | OrganizationUpdateWithWhereUniqueWithoutMembersInput[]
    | OrganizationUpdateWithWhereUniqueWithoutMembersInput;
  upsert?:
    | OrganizationUpsertWithWhereUniqueWithoutMembersInput[]
    | OrganizationUpsertWithWhereUniqueWithoutMembersInput;
  deleteMany?: OrganizationScalarWhereInput[] | OrganizationScalarWhereInput;
  updateMany?:
    | OrganizationUpdateManyWithWhereNestedInput[]
    | OrganizationUpdateManyWithWhereNestedInput;
}

export interface OrganizationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  members_every?: UserWhereInput;
  members_some?: UserWhereInput;
  members_none?: UserWhereInput;
  AND?: OrganizationWhereInput[] | OrganizationWhereInput;
  OR?: OrganizationWhereInput[] | OrganizationWhereInput;
  NOT?: OrganizationWhereInput[] | OrganizationWhereInput;
}

export interface OrganizationUpdateWithWhereUniqueWithoutMembersInput {
  where: OrganizationWhereUniqueInput;
  data: OrganizationUpdateWithoutMembersDataInput;
}

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  issue?: IssueWhereInput;
  parent?: CommentWhereInput;
  children_every?: CommentWhereInput;
  children_some?: CommentWhereInput;
  children_none?: CommentWhereInput;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface UserUpdateWithoutCommentsDataInput {
  firstName?: String;
  lastName?: String;
  gender?: String;
  username?: String;
  password?: String;
  email?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductUpdateManyWithoutUserInput;
  organizations?: OrganizationUpdateManyWithoutMembersInput;
  issues?: IssueUpdateManyWithoutAuthorInput;
}

export interface UserUpsertWithWhereUniqueWithoutOrganizationsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutOrganizationsDataInput;
  create: UserCreateWithoutOrganizationsInput;
}

export interface ProductUpdateManyWithoutUserInput {
  create?: ProductCreateWithoutUserInput[] | ProductCreateWithoutUserInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutUserInput[]
    | ProductUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutUserInput[]
    | ProductUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface OrganizationUpdateWithoutMembersDataInput {
  name?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductUpdateManyWithoutOrganizationInput;
}

export interface ProductUpdateWithWhereUniqueWithoutUserInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutUserDataInput;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  organization?: OrganizationWhereInput;
  issues_every?: IssueWhereInput;
  issues_some?: IssueWhereInput;
  issues_none?: IssueWhereInput;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface ProductUpdateWithoutUserDataInput {
  name?: String;
  description?: String;
  deletedAt?: DateTimeInput;
  organization?: OrganizationUpdateOneWithoutProductsInput;
  issues?: IssueUpdateManyWithoutProductInput;
}

export interface OrganizationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrganizationWhereInput;
  AND?:
    | OrganizationSubscriptionWhereInput[]
    | OrganizationSubscriptionWhereInput;
  OR?:
    | OrganizationSubscriptionWhereInput[]
    | OrganizationSubscriptionWhereInput;
  NOT?:
    | OrganizationSubscriptionWhereInput[]
    | OrganizationSubscriptionWhereInput;
}

export interface OrganizationUpdateOneWithoutProductsInput {
  create?: OrganizationCreateWithoutProductsInput;
  update?: OrganizationUpdateWithoutProductsDataInput;
  upsert?: OrganizationUpsertWithoutProductsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: OrganizationWhereUniqueInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface OrganizationUpdateWithoutProductsDataInput {
  name?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  members?: UserUpdateManyWithoutOrganizationsInput;
}

export interface UserUpdateInput {
  firstName?: String;
  lastName?: String;
  gender?: String;
  username?: String;
  password?: String;
  email?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductUpdateManyWithoutUserInput;
  organizations?: OrganizationUpdateManyWithoutMembersInput;
  issues?: IssueUpdateManyWithoutAuthorInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
}

export interface UserUpdateManyWithoutOrganizationsInput {
  create?:
    | UserCreateWithoutOrganizationsInput[]
    | UserCreateWithoutOrganizationsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutOrganizationsInput[]
    | UserUpdateWithWhereUniqueWithoutOrganizationsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutOrganizationsInput[]
    | UserUpsertWithWhereUniqueWithoutOrganizationsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateManyMutationInput {
  name?: String;
  description?: String;
  deletedAt?: DateTimeInput;
}

export interface UserUpdateWithWhereUniqueWithoutOrganizationsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutOrganizationsDataInput;
}

export type IssueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutOrganizationsDataInput {
  firstName?: String;
  lastName?: String;
  gender?: String;
  username?: String;
  password?: String;
  email?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductUpdateManyWithoutUserInput;
  issues?: IssueUpdateManyWithoutAuthorInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
}

export interface OrganizationUpdateManyMutationInput {
  name?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
}

export interface IssueUpdateManyWithoutAuthorInput {
  create?: IssueCreateWithoutAuthorInput[] | IssueCreateWithoutAuthorInput;
  delete?: IssueWhereUniqueInput[] | IssueWhereUniqueInput;
  connect?: IssueWhereUniqueInput[] | IssueWhereUniqueInput;
  disconnect?: IssueWhereUniqueInput[] | IssueWhereUniqueInput;
  update?:
    | IssueUpdateWithWhereUniqueWithoutAuthorInput[]
    | IssueUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | IssueUpsertWithWhereUniqueWithoutAuthorInput[]
    | IssueUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: IssueScalarWhereInput[] | IssueScalarWhereInput;
  updateMany?:
    | IssueUpdateManyWithWhereNestedInput[]
    | IssueUpdateManyWithWhereNestedInput;
}

export type OrganizationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface IssueUpdateWithWhereUniqueWithoutAuthorInput {
  where: IssueWhereUniqueInput;
  data: IssueUpdateWithoutAuthorDataInput;
}

export interface IssueUpdateManyMutationInput {
  title?: String;
  body?: String;
  deletedAt?: DateTimeInput;
}

export interface IssueUpdateWithoutAuthorDataInput {
  title?: String;
  body?: String;
  deletedAt?: DateTimeInput;
  product?: ProductUpdateOneRequiredWithoutIssuesInput;
  comments?: CommentUpdateManyWithoutIssueInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface CommentUpdateManyMutationInput {
  body?: String;
  deletedAt?: DateTimeInput;
}

export interface ProductUpdateWithoutIssuesDataInput {
  name?: String;
  description?: String;
  deletedAt?: DateTimeInput;
  user?: UserUpdateOneWithoutProductsInput;
  organization?: OrganizationUpdateOneWithoutProductsInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
  email?: String;
}>;

export interface UserUpdateOneWithoutProductsInput {
  create?: UserCreateWithoutProductsInput;
  update?: UserUpdateWithoutProductsDataInput;
  upsert?: UserUpsertWithoutProductsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface OrganizationUpsertWithoutProductsInput {
  update: OrganizationUpdateWithoutProductsDataInput;
  create: OrganizationCreateWithoutProductsInput;
}

export interface UserUpdateWithoutProductsDataInput {
  firstName?: String;
  lastName?: String;
  gender?: String;
  username?: String;
  password?: String;
  email?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  organizations?: OrganizationUpdateManyWithoutMembersInput;
  issues?: IssueUpdateManyWithoutAuthorInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  connect?: UserWhereUniqueInput;
}

export interface IssueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  product?: ProductWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  AND?: IssueWhereInput[] | IssueWhereInput;
  OR?: IssueWhereInput[] | IssueWhereInput;
  NOT?: IssueWhereInput[] | IssueWhereInput;
}

export interface ProductCreateManyWithoutUserInput {
  create?: ProductCreateWithoutUserInput[] | ProductCreateWithoutUserInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  gender?: String;
  gender_not?: String;
  gender_in?: String[] | String;
  gender_not_in?: String[] | String;
  gender_lt?: String;
  gender_lte?: String;
  gender_gt?: String;
  gender_gte?: String;
  gender_contains?: String;
  gender_not_contains?: String;
  gender_starts_with?: String;
  gender_not_starts_with?: String;
  gender_ends_with?: String;
  gender_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  organizations_every?: OrganizationWhereInput;
  organizations_some?: OrganizationWhereInput;
  organizations_none?: OrganizationWhereInput;
  issues_every?: IssueWhereInput;
  issues_some?: IssueWhereInput;
  issues_none?: IssueWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface OrganizationCreateOneWithoutProductsInput {
  create?: OrganizationCreateWithoutProductsInput;
  connect?: OrganizationWhereUniqueInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  gender?: String;
  gender_not?: String;
  gender_in?: String[] | String;
  gender_not_in?: String[] | String;
  gender_lt?: String;
  gender_lte?: String;
  gender_gt?: String;
  gender_gte?: String;
  gender_contains?: String;
  gender_not_contains?: String;
  gender_starts_with?: String;
  gender_not_starts_with?: String;
  gender_ends_with?: String;
  gender_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserCreateManyWithoutOrganizationsInput {
  create?:
    | UserCreateWithoutOrganizationsInput[]
    | UserCreateWithoutOrganizationsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface ProductUpdateManyWithoutOrganizationInput {
  create?:
    | ProductCreateWithoutOrganizationInput[]
    | ProductCreateWithoutOrganizationInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutOrganizationInput[]
    | ProductUpdateWithWhereUniqueWithoutOrganizationInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutOrganizationInput[]
    | ProductUpsertWithWhereUniqueWithoutOrganizationInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface IssueCreateManyWithoutAuthorInput {
  create?: IssueCreateWithoutAuthorInput[] | IssueCreateWithoutAuthorInput;
  connect?: IssueWhereUniqueInput[] | IssueWhereUniqueInput;
}

export interface ProductUpdateWithWhereUniqueWithoutOrganizationInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutOrganizationDataInput;
}

export interface ProductCreateOneWithoutIssuesInput {
  create?: ProductCreateWithoutIssuesInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductUpdateWithoutOrganizationDataInput {
  name?: String;
  description?: String;
  deletedAt?: DateTimeInput;
  user?: UserUpdateOneWithoutProductsInput;
  issues?: IssueUpdateManyWithoutProductInput;
}

export interface UserCreateOneWithoutProductsInput {
  create?: UserCreateWithoutProductsInput;
  connect?: UserWhereUniqueInput;
}

export interface IssueUpdateManyWithoutProductInput {
  create?: IssueCreateWithoutProductInput[] | IssueCreateWithoutProductInput;
  delete?: IssueWhereUniqueInput[] | IssueWhereUniqueInput;
  connect?: IssueWhereUniqueInput[] | IssueWhereUniqueInput;
  disconnect?: IssueWhereUniqueInput[] | IssueWhereUniqueInput;
  update?:
    | IssueUpdateWithWhereUniqueWithoutProductInput[]
    | IssueUpdateWithWhereUniqueWithoutProductInput;
  upsert?:
    | IssueUpsertWithWhereUniqueWithoutProductInput[]
    | IssueUpsertWithWhereUniqueWithoutProductInput;
  deleteMany?: IssueScalarWhereInput[] | IssueScalarWhereInput;
  updateMany?:
    | IssueUpdateManyWithWhereNestedInput[]
    | IssueUpdateManyWithWhereNestedInput;
}

export interface OrganizationCreateManyWithoutMembersInput {
  create?:
    | OrganizationCreateWithoutMembersInput[]
    | OrganizationCreateWithoutMembersInput;
  connect?: OrganizationWhereUniqueInput[] | OrganizationWhereUniqueInput;
}

export interface IssueUpdateWithWhereUniqueWithoutProductInput {
  where: IssueWhereUniqueInput;
  data: IssueUpdateWithoutProductDataInput;
}

export interface ProductCreateManyWithoutOrganizationInput {
  create?:
    | ProductCreateWithoutOrganizationInput[]
    | ProductCreateWithoutOrganizationInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface IssueUpdateWithoutProductDataInput {
  title?: String;
  body?: String;
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutIssuesInput;
  comments?: CommentUpdateManyWithoutIssueInput;
}

export interface IssueCreateManyWithoutProductInput {
  create?: IssueCreateWithoutProductInput[] | IssueCreateWithoutProductInput;
  connect?: IssueWhereUniqueInput[] | IssueWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutIssuesInput {
  create?: UserCreateWithoutIssuesInput;
  update?: UserUpdateWithoutIssuesDataInput;
  upsert?: UserUpsertWithoutIssuesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateOneWithoutIssuesInput {
  create?: UserCreateWithoutIssuesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutIssuesDataInput {
  firstName?: String;
  lastName?: String;
  gender?: String;
  username?: String;
  password?: String;
  email?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductUpdateManyWithoutUserInput;
  organizations?: OrganizationUpdateManyWithoutMembersInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
}

export interface CommentCreateManyWithoutAuthorInput {
  create?: CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentUpdateManyWithoutAuthorInput {
  create?: CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    | CommentUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    | CommentUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface IssueCreateOneWithoutCommentsInput {
  create?: IssueCreateWithoutCommentsInput;
  connect?: IssueWhereUniqueInput;
}

export interface CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutAuthorDataInput;
}

export interface CommentCreateOneWithoutChildrenInput {
  create?: CommentCreateWithoutChildrenInput;
  connect?: CommentWhereUniqueInput;
}

export interface CommentUpdateWithoutAuthorDataInput {
  body?: String;
  deletedAt?: DateTimeInput;
  issue?: IssueUpdateOneWithoutCommentsInput;
  parent?: CommentUpdateOneWithoutChildrenInput;
  children?: CommentUpdateManyWithoutParentInput;
}

export interface CommentCreateManyWithoutParentInput {
  create?: CommentCreateWithoutParentInput[] | CommentCreateWithoutParentInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface IssueUpdateOneWithoutCommentsInput {
  create?: IssueCreateWithoutCommentsInput;
  update?: IssueUpdateWithoutCommentsDataInput;
  upsert?: IssueUpsertWithoutCommentsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: IssueWhereUniqueInput;
}

export interface CommentCreateManyWithoutIssueInput {
  create?: CommentCreateWithoutIssueInput[] | CommentCreateWithoutIssueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface IssueUpdateWithoutCommentsDataInput {
  title?: String;
  body?: String;
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutIssuesInput;
  product?: ProductUpdateOneRequiredWithoutIssuesInput;
}

export interface CommentUpdateInput {
  body?: String;
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
  issue?: IssueUpdateOneWithoutCommentsInput;
  parent?: CommentUpdateOneWithoutChildrenInput;
  children?: CommentUpdateManyWithoutParentInput;
}

export interface IssueUpsertWithoutCommentsInput {
  update: IssueUpdateWithoutCommentsDataInput;
  create: IssueCreateWithoutCommentsInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CommentUpdateOneWithoutChildrenInput {
  create?: CommentCreateWithoutChildrenInput;
  update?: CommentUpdateWithoutChildrenDataInput;
  upsert?: CommentUpsertWithoutChildrenInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CommentWhereUniqueInput;
}

export interface IssueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: IssueWhereInput;
  AND?: IssueSubscriptionWhereInput[] | IssueSubscriptionWhereInput;
  OR?: IssueSubscriptionWhereInput[] | IssueSubscriptionWhereInput;
  NOT?: IssueSubscriptionWhereInput[] | IssueSubscriptionWhereInput;
}

export interface CommentUpdateWithoutChildrenDataInput {
  body?: String;
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
  issue?: IssueUpdateOneWithoutCommentsInput;
  parent?: CommentUpdateOneWithoutChildrenInput;
}

export interface UserCreateInput {
  firstName: String;
  lastName: String;
  gender: String;
  username: String;
  password: String;
  email: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductCreateManyWithoutUserInput;
  organizations?: OrganizationCreateManyWithoutMembersInput;
  issues?: IssueCreateManyWithoutAuthorInput;
  comments?: CommentCreateManyWithoutAuthorInput;
}

export interface CommentUpsertWithoutChildrenInput {
  update: CommentUpdateWithoutChildrenDataInput;
  create: CommentCreateWithoutChildrenInput;
}

export interface ProductCreateInput {
  name: String;
  description?: String;
  deletedAt?: DateTimeInput;
  user?: UserCreateOneWithoutProductsInput;
  organization?: OrganizationCreateOneWithoutProductsInput;
  issues?: IssueCreateManyWithoutProductInput;
}

export interface CommentUpdateManyWithoutParentInput {
  create?: CommentCreateWithoutParentInput[] | CommentCreateWithoutParentInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutParentInput[]
    | CommentUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutParentInput[]
    | CommentUpsertWithWhereUniqueWithoutParentInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface OrganizationCreateInput {
  name: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductCreateManyWithoutOrganizationInput;
  members?: UserCreateManyWithoutOrganizationsInput;
}

export interface CommentUpdateWithWhereUniqueWithoutParentInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutParentDataInput;
}

export interface IssueCreateInput {
  title: String;
  body: String;
  deletedAt?: DateTimeInput;
  author: UserCreateOneWithoutIssuesInput;
  product: ProductCreateOneWithoutIssuesInput;
  comments?: CommentCreateManyWithoutIssueInput;
}

export interface CommentUpdateWithoutParentDataInput {
  body?: String;
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
  issue?: IssueUpdateOneWithoutCommentsInput;
  children?: CommentUpdateManyWithoutParentInput;
}

export interface ProductUpsertWithWhereUniqueWithoutUserInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutUserDataInput;
  create: ProductCreateWithoutUserInput;
}

export interface CommentUpsertWithWhereUniqueWithoutParentInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutParentDataInput;
  create: CommentCreateWithoutParentInput;
}

export interface CommentCreateInput {
  body: String;
  deletedAt?: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  issue?: IssueCreateOneWithoutCommentsInput;
  parent?: CommentCreateOneWithoutChildrenInput;
  children?: CommentCreateManyWithoutParentInput;
}

export interface CommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface ProductCreateWithoutUserInput {
  name: String;
  description?: String;
  deletedAt?: DateTimeInput;
  organization?: OrganizationCreateOneWithoutProductsInput;
  issues?: IssueCreateManyWithoutProductInput;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface UserCreateWithoutOrganizationsInput {
  firstName: String;
  lastName: String;
  gender: String;
  username: String;
  password: String;
  email: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductCreateManyWithoutUserInput;
  issues?: IssueCreateManyWithoutAuthorInput;
  comments?: CommentCreateManyWithoutAuthorInput;
}

export interface CommentUpdateManyDataInput {
  body?: String;
  deletedAt?: DateTimeInput;
}

export interface ProductCreateWithoutIssuesInput {
  name: String;
  description?: String;
  deletedAt?: DateTimeInput;
  user?: UserCreateOneWithoutProductsInput;
  organization?: OrganizationCreateOneWithoutProductsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutAuthorDataInput;
  create: CommentCreateWithoutAuthorInput;
}

export interface OrganizationCreateWithoutMembersInput {
  name: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductCreateManyWithoutOrganizationInput;
}

export interface UserUpsertWithoutIssuesInput {
  update: UserUpdateWithoutIssuesDataInput;
  create: UserCreateWithoutIssuesInput;
}

export interface IssueCreateWithoutProductInput {
  title: String;
  body: String;
  deletedAt?: DateTimeInput;
  author: UserCreateOneWithoutIssuesInput;
  comments?: CommentCreateManyWithoutIssueInput;
}

export interface CommentUpdateManyWithoutIssueInput {
  create?: CommentCreateWithoutIssueInput[] | CommentCreateWithoutIssueInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutIssueInput[]
    | CommentUpdateWithWhereUniqueWithoutIssueInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutIssueInput[]
    | CommentUpsertWithWhereUniqueWithoutIssueInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentCreateWithoutAuthorInput {
  body: String;
  deletedAt?: DateTimeInput;
  issue?: IssueCreateOneWithoutCommentsInput;
  parent?: CommentCreateOneWithoutChildrenInput;
  children?: CommentCreateManyWithoutParentInput;
}

export interface CommentUpdateWithWhereUniqueWithoutIssueInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutIssueDataInput;
}

export interface CommentCreateWithoutChildrenInput {
  body: String;
  deletedAt?: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  issue?: IssueCreateOneWithoutCommentsInput;
  parent?: CommentCreateOneWithoutChildrenInput;
}

export interface CommentUpdateWithoutIssueDataInput {
  body?: String;
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
  parent?: CommentUpdateOneWithoutChildrenInput;
  children?: CommentUpdateManyWithoutParentInput;
}

export interface CommentCreateWithoutIssueInput {
  body: String;
  deletedAt?: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  parent?: CommentCreateOneWithoutChildrenInput;
  children?: CommentCreateManyWithoutParentInput;
}

export interface CommentUpsertWithWhereUniqueWithoutIssueInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutIssueDataInput;
  create: CommentCreateWithoutIssueInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface IssueUpsertWithWhereUniqueWithoutProductInput {
  where: IssueWhereUniqueInput;
  update: IssueUpdateWithoutProductDataInput;
  create: IssueCreateWithoutProductInput;
}

export interface ProductUpdateInput {
  name?: String;
  description?: String;
  deletedAt?: DateTimeInput;
  user?: UserUpdateOneWithoutProductsInput;
  organization?: OrganizationUpdateOneWithoutProductsInput;
  issues?: IssueUpdateManyWithoutProductInput;
}

export interface IssueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  body?: String;
  body_not?: String;
  body_in?: String[] | String;
  body_not_in?: String[] | String;
  body_lt?: String;
  body_lte?: String;
  body_gt?: String;
  body_gte?: String;
  body_contains?: String;
  body_not_contains?: String;
  body_starts_with?: String;
  body_not_starts_with?: String;
  body_ends_with?: String;
  body_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  AND?: IssueScalarWhereInput[] | IssueScalarWhereInput;
  OR?: IssueScalarWhereInput[] | IssueScalarWhereInput;
  NOT?: IssueScalarWhereInput[] | IssueScalarWhereInput;
}

export interface IssueUpdateInput {
  title?: String;
  body?: String;
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutIssuesInput;
  product?: ProductUpdateOneRequiredWithoutIssuesInput;
  comments?: CommentUpdateManyWithoutIssueInput;
}

export interface IssueUpdateManyWithWhereNestedInput {
  where: IssueScalarWhereInput;
  data: IssueUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  firstName?: String;
  lastName?: String;
  gender?: String;
  username?: String;
  password?: String;
  email?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
}

export interface IssueUpdateManyDataInput {
  title?: String;
  body?: String;
  deletedAt?: DateTimeInput;
}

export interface OrganizationCreateWithoutProductsInput {
  name: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  members?: UserCreateManyWithoutOrganizationsInput;
}

export interface ProductUpsertWithWhereUniqueWithoutOrganizationInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutOrganizationDataInput;
  create: ProductCreateWithoutOrganizationInput;
}

export interface UserCreateWithoutProductsInput {
  firstName: String;
  lastName: String;
  gender: String;
  username: String;
  password: String;
  email: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  organizations?: OrganizationCreateManyWithoutMembersInput;
  issues?: IssueCreateManyWithoutAuthorInput;
  comments?: CommentCreateManyWithoutAuthorInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export interface UserCreateWithoutIssuesInput {
  firstName: String;
  lastName: String;
  gender: String;
  username: String;
  password: String;
  email: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductCreateManyWithoutUserInput;
  organizations?: OrganizationCreateManyWithoutMembersInput;
  comments?: CommentCreateManyWithoutAuthorInput;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface CommentCreateWithoutParentInput {
  body: String;
  deletedAt?: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  issue?: IssueCreateOneWithoutCommentsInput;
  children?: CommentCreateManyWithoutParentInput;
}

export interface ProductUpdateManyDataInput {
  name?: String;
  description?: String;
  deletedAt?: DateTimeInput;
}

export interface UserUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  gender?: String;
  username?: String;
  password?: String;
  email?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
}

export interface OrganizationUpsertWithWhereUniqueWithoutMembersInput {
  where: OrganizationWhereUniqueInput;
  update: OrganizationUpdateWithoutMembersDataInput;
  create: OrganizationCreateWithoutMembersInput;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface OrganizationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  AND?: OrganizationScalarWhereInput[] | OrganizationScalarWhereInput;
  OR?: OrganizationScalarWhereInput[] | OrganizationScalarWhereInput;
  NOT?: OrganizationScalarWhereInput[] | OrganizationScalarWhereInput;
}

export interface IssueCreateWithoutAuthorInput {
  title: String;
  body: String;
  deletedAt?: DateTimeInput;
  product: ProductCreateOneWithoutIssuesInput;
  comments?: CommentCreateManyWithoutIssueInput;
}

export interface OrganizationUpdateManyWithWhereNestedInput {
  where: OrganizationScalarWhereInput;
  data: OrganizationUpdateManyDataInput;
}

export interface IssueCreateWithoutCommentsInput {
  title: String;
  body: String;
  deletedAt?: DateTimeInput;
  author: UserCreateOneWithoutIssuesInput;
  product: ProductCreateOneWithoutIssuesInput;
}

export interface IssueUpsertWithWhereUniqueWithoutAuthorInput {
  where: IssueWhereUniqueInput;
  update: IssueUpdateWithoutAuthorDataInput;
  create: IssueCreateWithoutAuthorInput;
}

export interface ProductUpsertWithoutIssuesInput {
  update: ProductUpdateWithoutIssuesDataInput;
  create: ProductCreateWithoutIssuesInput;
}

export interface UserUpsertWithoutProductsInput {
  update: UserUpdateWithoutProductsDataInput;
  create: UserCreateWithoutProductsInput;
}

export interface OrganizationUpdateManyDataInput {
  name?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  update?: UserUpdateWithoutCommentsDataInput;
  upsert?: UserUpsertWithoutCommentsInput;
  connect?: UserWhereUniqueInput;
}

export interface ProductCreateWithoutOrganizationInput {
  name: String;
  description?: String;
  deletedAt?: DateTimeInput;
  user?: UserCreateOneWithoutProductsInput;
  issues?: IssueCreateManyWithoutProductInput;
}

export interface UserCreateWithoutCommentsInput {
  firstName: String;
  lastName: String;
  gender: String;
  username: String;
  password: String;
  email: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductCreateManyWithoutUserInput;
  organizations?: OrganizationCreateManyWithoutMembersInput;
  issues?: IssueCreateManyWithoutAuthorInput;
}

export interface OrganizationUpdateInput {
  name?: String;
  bio?: String;
  deletedAt?: DateTimeInput;
  products?: ProductUpdateManyWithoutOrganizationInput;
  members?: UserUpdateManyWithoutOrganizationsInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  gender: String;
  username: String;
  password: String;
  email: String;
  bio?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  bio: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  firstName: String;
  lastName: String;
  gender: String;
  username: String;
  password: String;
  email: String;
  bio?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  bio: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  organizations: <T = FragmentableArray<Organization>>(
    args?: {
      where?: OrganizationWhereInput;
      orderBy?: OrganizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  issues: <T = FragmentableArray<Issue>>(
    args?: {
      where?: IssueWhereInput;
      orderBy?: IssueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  organizations: <T = Promise<AsyncIterator<OrganizationSubscription>>>(
    args?: {
      where?: OrganizationWhereInput;
      orderBy?: OrganizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  issues: <T = Promise<AsyncIterator<IssueSubscription>>>(
    args?: {
      where?: IssueWhereInput;
      orderBy?: IssueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Product {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  organization: <T = OrganizationPromise>() => T;
  issues: <T = FragmentableArray<Issue>>(
    args?: {
      where?: IssueWhereInput;
      orderBy?: IssueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  organization: <T = OrganizationSubscription>() => T;
  issues: <T = Promise<AsyncIterator<IssueSubscription>>>(
    args?: {
      where?: IssueWhereInput;
      orderBy?: IssueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Organization {
  id: ID_Output;
  name: String;
  bio?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface OrganizationPromise
  extends Promise<Organization>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  bio: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  members: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface OrganizationSubscription
  extends Promise<AsyncIterator<Organization>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface Comment {
  id: ID_Output;
  body: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  issue: <T = IssuePromise>() => T;
  parent: <T = CommentPromise>() => T;
  children: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  issue: <T = IssueSubscription>() => T;
  parent: <T = CommentSubscription>() => T;
  children: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface OrganizationEdge {
  node: Organization;
  cursor: String;
}

export interface OrganizationEdgePromise
  extends Promise<OrganizationEdge>,
    Fragmentable {
  node: <T = OrganizationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrganizationEdgeSubscription
  extends Promise<AsyncIterator<OrganizationEdge>>,
    Fragmentable {
  node: <T = OrganizationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface AggregateIssue {
  count: Int;
}

export interface AggregateIssuePromise
  extends Promise<AggregateIssue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIssueSubscription
  extends Promise<AsyncIterator<AggregateIssue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentPreviousValues {
  id: ID_Output;
  body: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface IssueConnection {
  pageInfo: PageInfo;
  edges: IssueEdge[];
}

export interface IssueConnectionPromise
  extends Promise<IssueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IssueEdge>>() => T;
  aggregate: <T = AggregateIssuePromise>() => T;
}

export interface IssueConnectionSubscription
  extends Promise<AsyncIterator<IssueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IssueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIssueSubscription>() => T;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface IssueSubscriptionPayload {
  mutation: MutationType;
  node: Issue;
  updatedFields: String[];
  previousValues: IssuePreviousValues;
}

export interface IssueSubscriptionPayloadPromise
  extends Promise<IssueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IssuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IssuePreviousValuesPromise>() => T;
}

export interface IssueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IssueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IssueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IssuePreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface OrganizationConnection {
  pageInfo: PageInfo;
  edges: OrganizationEdge[];
}

export interface OrganizationConnectionPromise
  extends Promise<OrganizationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrganizationEdge>>() => T;
  aggregate: <T = AggregateOrganizationPromise>() => T;
}

export interface OrganizationConnectionSubscription
  extends Promise<AsyncIterator<OrganizationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrganizationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrganizationSubscription>() => T;
}

export interface OrganizationPreviousValues {
  id: ID_Output;
  name: String;
  bio?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface OrganizationPreviousValuesPromise
  extends Promise<OrganizationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  bio: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
}

export interface OrganizationPreviousValuesSubscription
  extends Promise<AsyncIterator<OrganizationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrganizationSubscriptionPayload {
  mutation: MutationType;
  node: Organization;
  updatedFields: String[];
  previousValues: OrganizationPreviousValues;
}

export interface OrganizationSubscriptionPayloadPromise
  extends Promise<OrganizationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrganizationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrganizationPreviousValuesPromise>() => T;
}

export interface OrganizationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrganizationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrganizationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrganizationPreviousValuesSubscription>() => T;
}

export interface Issue {
  id: ID_Output;
  title: String;
  body: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface IssuePromise extends Promise<Issue>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  body: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  product: <T = ProductPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface IssueSubscription
  extends Promise<AsyncIterator<Issue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  product: <T = ProductSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface IssuePreviousValues {
  id: ID_Output;
  title: String;
  body: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
}

export interface IssuePreviousValuesPromise
  extends Promise<IssuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  body: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
}

export interface IssuePreviousValuesSubscription
  extends Promise<AsyncIterator<IssuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface IssueEdge {
  node: Issue;
  cursor: String;
}

export interface IssueEdgePromise extends Promise<IssueEdge>, Fragmentable {
  node: <T = IssuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface IssueEdgeSubscription
  extends Promise<AsyncIterator<IssueEdge>>,
    Fragmentable {
  node: <T = IssueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrganization {
  count: Int;
}

export interface AggregateOrganizationPromise
  extends Promise<AggregateOrganization>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrganizationSubscription
  extends Promise<AsyncIterator<AggregateOrganization>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Issue",
    embedded: false
  },
  {
    name: "Organization",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["DB_ENDPOINT"]}`,
  secret: `${process.env["DB_SECRET"]}`
});
export const prisma = new Prisma();
